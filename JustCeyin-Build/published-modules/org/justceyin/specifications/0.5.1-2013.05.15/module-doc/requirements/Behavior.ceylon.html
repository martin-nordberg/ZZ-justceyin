<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>Behavior.ceylon</title><link href='../.resources/shCore.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/shThemeDefault.css' rel='stylesheet' type='text/css'/>
<script type='text/javascript' src='../.resources/jquery-1.8.2.min.js'></script><script type='text/javascript' src='../.resources/ceylondoc.js'></script><script src='../.resources/shCore.js' type='text/javascript'></script><script src='../.resources/shBrushCeylon.js' type='text/javascript'></script></head><body><pre class='brush: ceylon'>
import org.justceyin.expectations.constraints { 
    Constraint 
}

&quot;Intermediate result in a fluent interface for declarative specifications - represents a set of starting values
 and a set up operation that transforms those starting values into a testable outcome.&quot;
by &quot;Martin E. Nordberg III&quot;
shared class Behavior&lt;Input,Output&gt;(
    &quot;Sequence of functions providing starting values for the requirement.&quot;
    {Input()+} startingValues, 
    &quot;Operation to be applied to an input to generate the testable output.&quot;
    Output setup( Input input ) 
) {
    
    &quot;Defines a requirement by applying a constraint to the transformed output.&quot;
    shared Requirement expect(
        &quot;A constraint that should be satisfied by the transformed output value&quot;
        Constraint&lt;Output&gt; constraint 
    ) {
        return BehaviorRequirement&lt;Input,Output&gt;( startingValues, setup, constraint );
    }
    
    &quot;Defines a requirement that expects an exception to be thrown by the setup/transform process.&quot;
    shared Requirement expectAnException&lt;ExceptionType&gt;()
        given ExceptionType satisfies Exception {
        return ExpectedExceptionRequirement&lt;Input,Output,ExceptionType&gt;( startingValues, setup );
    }
    
    &quot;Defines a requirement that expects a nonexistent outcome.&quot;
    shared Requirement expectNonexistentResult() {
        return NonexistenceRequirement&lt;Input,Output&gt;( startingValues, setup );
    }
    
    &quot;Augments the set up operation of this behavior to produce a new behavior with composed set up operation.&quot;
    shared Behavior&lt;Input,Output2&gt; followedBy&lt;Output2&gt;(
        &quot;A second transform to be applied before the final result is constrained&quot;
        Output2 setup2( Output input2 ) 
    ) {
        return Behavior&lt;Input,Output2&gt;( startingValues, compose(setup2, setup) );
    }
    
}
</pre></body></html>