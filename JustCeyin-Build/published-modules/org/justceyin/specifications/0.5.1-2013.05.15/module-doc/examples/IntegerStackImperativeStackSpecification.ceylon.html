<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>IntegerStackImperativeStackSpecification.ceylon</title><link href='../.resources/shCore.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/shThemeDefault.css' rel='stylesheet' type='text/css'/>
<script type='text/javascript' src='../.resources/jquery-1.8.2.min.js'></script><script type='text/javascript' src='../.resources/ceylondoc.js'></script><script src='../.resources/shCore.js' type='text/javascript'></script><script src='../.resources/shBrushCeylon.js' type='text/javascript'></script></head><body><pre class='brush: ceylon'>
import org.justceyin.expectations { 
    expect 
}
import org.justceyin.expectations.constraints { 
    ConstraintCheckResult
}
import org.justceyin.expectations.constraints.providers { 
    anInteger 
}
import org.justceyin.specifications { 
    ImperativeSpecification 
}

&quot;An example specification illustrating how to go about creating an imperative specification defined in
 terms of test methods, where each requirement uses the fluent interface of org.justceyin.expectations
 to declare expected outcomes for the results of the test.&quot;
shared class IntegerStackImperativeSpecification()
    satisfies ImperativeSpecification
{
    
    shared actual String title = &quot;IntegerStackImperativeSpecification&quot;; 
    
    // constraints
    value anIntegerStack = StackConstraints&lt;Integer&gt;();
    
    &quot;A stack starts out empty.&quot;
    void testNewStack( void outcomes( ConstraintCheckResult* results ) ) {
        value stack = Stack&lt;Integer&gt;();
        outcomes( expect( stack ).named( &quot;stack&quot; ).toBe( anIntegerStack.thatIsEmpty ),
                  expect( stack.topIfPresent ).named( &quot;top of stack&quot; ).toNotExist() );
    }
    
    &quot;A pushed value becomes the new top of the stack.&quot;
    void testPush( void outcomes( ConstraintCheckResult* results ) ) {
        value stack = Stack&lt;Integer&gt;().push(1);
        outcomes( expect( stack.top ).named( &quot;top of stack&quot; ).toBe( anInteger.withValue(1) ) );
    }
    
    &quot;Pushing then popping leaves the original stack.&quot;
    void testPushThenPop( void outcomes( ConstraintCheckResult* results ) ) {
        value stack = Stack&lt;Integer&gt;().push(1).pop();
        outcomes( expect( stack ).named( &quot;stack&quot; ).toBe( anIntegerStack.thatIsEmpty ),
                  expect( stack.topIfPresent ).named( &quot;top of stack&quot; ).toNotExist() );
    }
    
    &quot;Pushing then popping leaves the original stack (intermediate steps checked).&quot;
    void testPushThenPopSequence( void outcomes( ConstraintCheckResult* results ) ) {
        value stack0 = Stack&lt;Integer&gt;();
        
        outcomes( expect( stack0 ).named( &quot;stack&quot; ).toBe( anIntegerStack.thatIsEmpty ),
                  expect( stack0.topIfPresent ).named( &quot;top of stack&quot; ).toNotExist() );

        value stack1 = stack0.push( 1 );
        
        outcomes( expect( stack1.top ).named( &quot;top of stack&quot; ).toBe( anInteger.withValue(1) ) );
        
        value stack2 = stack1.pop();
        
        outcomes( expect( stack2 ).named( &quot;stack&quot; ).toBe( anIntegerStack.thatIsEmpty ),
                  expect( stack2.topIfPresent ).named( &quot;top of stack&quot; ).toNotExist() );
    }
    
    &quot;The tests within this specification. (TBD: to be replaced by annotations (M6).&quot;
    shared actual {Anything(Anything(ConstraintCheckResult*))+} tests = {
        testNewStack,
        testPush,
        testPushThenPop,
        testPushThenPopSequence
    };
    
}

</pre></body></html>